#include "McopySerial.h"


//Can be controlled via serial, with mcopy and filmout_manager
//Buttons are optional
//Exposure controls assumes use  of a 120RPM motor
//Uses L298N H-bridge breakout board
//Target board is an Arduino Nano

/*
----------------------------------------------------
Microswitch (use INPUT_PULLUP!!)
GND-----\ | \-----PIN
----------------------------------------------------
*/

const int MOTOR_RPM = 120;
const int BOLEX_C = round((133 / (1.66 * 360)) * 1000); //bolex exposure constant
const int FAST_PWM = 255;

/* ------------------------------------------------
 *  pins
 * ------------------------------------------------*/
//Arduino Nano
const int PIN_INDICATOR = 13;
const int PIN_MOTOR_FORWARD = 9;
const int PIN_MOTOR_BACKWARD = 10;
const int PIN_MICRO = 19;
//6, 5, 4
//1, 2, 3
const int BUTTONS[4] = {3, 4, 5, 6};  //trigger, delay, speed, direction

const float FWD_OPEN = 0.4;
const float BWD_OPEN = 0.7;

/* ------------------------------------------------
 *  loop
 * ------------------------------------------------*/
const int LOOP_DELAY = 10;

/* ------------------------------------------------
 *  state
 * ------------------------------------------------*/
volatile int button_states[4] = {1, 1, 1, 1};
volatile long button_times[4] = {0, 0, 0, 0};
volatile long buttontime = 0;

volatile boolean timelapse = false;
volatile boolean running = false;
volatile boolean direction = true;
volatile boolean delaying = false;
volatile boolean timed_exposure = false;

volatile int counter = 0;

volatile int microswitch_position = 0;
volatile boolean microswitch_primed = false;

unsigned long timer = 0;
unsigned long frame_start = 0;
unsigned long delay_start = 0;

String timed_exposure_str = "600";
unsigned long timed_exposure_val = 600;
unsigned long timed_open = 100; //ms after start_frame to pause
volatile boolean timed_exposure_open = false;
unsigned long timed_delay = 0;
unsigned long timed_exposure_last = 0;

unsigned long timed_avg = 600;
unsigned long i_avg = 600;

volatile int fwd_speed = FAST_PWM;
volatile int bwd_speed = FAST_PWM;

volatile long timelapse_delay = 42;
volatile boolean open = false;

/* ------------------------------------------------
 *  serial
 * ------------------------------------------------*/
McopySerial mc;
volatile char cmd_char = 'z';

void setup() {
  mc.begin(mc.CAMERA_IDENTIFIER);
  PinsInit();
  ButtonsInit();
  timed_open = OpenTiming();
}

void loop() {
  cmd_char = mc.loop();
  cmd(cmd_char);

  timer = millis();
  
  Button(0);
  Button(1);
  Button(2);
  Button(3);
  
  if (timelapse && delaying) {
    WatchDelay();
  }
  
  if (running) {
    if (timed_exposure) {
     ReadTimed();  
    } else {
     ReadMicro(); 
    }
  }
  if (!running && !timelapse && !delaying){ 
    delay(LOOP_DELAY);
  }
}

void cmd (char val) {
  if (val == mc.CAMERA) {
    Camera();
  } else if (val == mc.CAMERA_FORWARD) {
    CameraDirection(true);
  } else if (val == mc.CAMERA_BACKWARD) {
    CameraDirection(false);
  } else if (val == mc.CAMERA_OPEN) {
    CameraOpen();
  } else if (val == mc.CAMERA_CLOSE) {
    CameraClose();
  } else if (val == mc.CAMERA_EXPOSURE) {
    CameraExposure();  
  } else if (val == mc.STATE) {
    State();
  }
}



//sending "0" will reset to default exposure time
void CameraExposure () {
  timed_exposure_str = mc.getString();
  timed_exposure_val = timed_exposure_str.toInt();
  if (timed_exposure_val < 600) {
    timed_exposure_val = 600;
    timed_exposure_str = "600";
    timed_exposure= false;
    timed_open = OpenTiming();
  } else {
    //timed_delay = timed_exposure_val - BOLEX_C;
    timed_exposure = true;
  }
  mc.confirm(mc.CAMERA_EXPOSURE);
  mc.log("Set exposure time to: ");
  mc.log(timed_exposure_str);
}

void PinsInit () {
  pinMode(PIN_MOTOR_FORWARD, OUTPUT);
  pinMode(PIN_MOTOR_BACKWARD, OUTPUT);
  pinMode(PIN_MICRO, INPUT_PULLUP);
  pinMode(PIN_INDICATOR, OUTPUT);
}

void ButtonsInit () {
  for (int i = 0; i < 4; i++) {
    pinMode(BUTTONS[i], INPUT_PULLUP);
  }
}

void Button (int index) {
  int val = digitalRead(BUTTONS[index]);
  if (val != button_states[index]) {
    if (val == LOW) { // pressed
      button_times[index] = millis();
      //button_start(index);
    } else if (val == HIGH) { // not pressed
      buttontime = millis() - button_times[index];
      ButtonEnd(index, buttontime);
    }
  }
  button_states[index] = val;
}

/*
 * dormant for now
 * void button_start (int index) {
  if (index == 0) {
  }
}*/

void ButtonEnd (int index, long buttontime) {
  if (index == 0) {
    if (buttontime > 1000) {
      if (!timelapse && !running) {
        timelapse = true;
        Output(2, 75);
        Camera();
      }
    } else {
       if (timelapse) {
        timelapse = false;
        //Output(2, 75);
      } else {
         Camera();
      }
    }
  } else if (index == 1) { //set delay
    if (buttontime < 42) {
      timelapse_delay = 42;
      Output(1, 500);
    } else {
      timelapse_delay = buttontime;
      Output(2, 250);
    }
  }  else if (index == 2) { // set speed
    if (buttontime >= 1000) {
      //timed_delay = buttontime - BOLEX_C;
      timed_exposure = true;
      Output(2, 250);
    } else if (buttontime < 1000) {
      //timed_delay = 0;
      timed_exposure = false;
      Output(1, 500);    
    }
  } else if (index == 3) { //set direction
    if (buttontime < 1000) {
      direction = true;
      Output(1, 500);
    } else if (buttontime > 1000) {
      direction = false;
      Output(2, 250);
    }
  }
  buttontime = 0;
}

void Indicator (boolean state) {
  if (state) {
    digitalWrite(PIN_INDICATOR, HIGH);
  } else {
    digitalWrite(PIN_INDICATOR, LOW);
  }
}

void Output (int number, int len) {
  for (int i = 0; i < number; i++) {
    Indicator(true);
    delay(len);
    Indicator(false);
    delay(42);
  }
}

void Camera () {
  frame_start = millis();
  if (direction) {
    analogWrite(PIN_MOTOR_FORWARD, fwd_speed);
    analogWrite(PIN_MOTOR_BACKWARD, 0);
  } else {
    analogWrite(PIN_MOTOR_BACKWARD, bwd_speed);
    analogWrite(PIN_MOTOR_FORWARD, 0);
  }
  running = true;
  microswitch_primed = false;
}

long OpenTiming () {
  return direction ? (long) (FWD_OPEN * i_avg) : (long) (BWD_OPEN * i_avg);
}

void CameraOpen () {
  if (direction) {
    analogWrite(PIN_MOTOR_FORWARD, fwd_speed);
    analogWrite(PIN_MOTOR_BACKWARD, 0);
  } else {
    analogWrite(PIN_MOTOR_BACKWARD, bwd_speed);
    analogWrite(PIN_MOTOR_FORWARD, 0);
  }
  running = true;
  microswitch_primed = false;
  
  delay(OpenTiming());

  analogWrite(PIN_MOTOR_FORWARD, 0);
  analogWrite(PIN_MOTOR_BACKWARD, 0);

  microswitch_position = digitalRead(PIN_MICRO);
  if (microswitch_position == LOW) {
    microswitch_primed = true;
  }

  mc.confirm(mc.CAMERA_OPEN);
  mc.log("camera_open()");
  open = true;
  running = false;
}

void CameraClose () {
  bool microswitch_open = false;
  if (open) {
    if (direction) {
      analogWrite(PIN_MOTOR_FORWARD, fwd_speed);
      analogWrite(PIN_MOTOR_BACKWARD, 0);
    } else {
      analogWrite(PIN_MOTOR_BACKWARD, bwd_speed);
      analogWrite(PIN_MOTOR_FORWARD, 0);
    }

    while (!microswitch_open) {
      microswitch_position = digitalRead(PIN_MICRO);
      if (microswitch_position == HIGH) {
        microswitch_open = true;
      }
      delay(2);
    }
    delay(10);

    analogWrite(PIN_MOTOR_FORWARD, 0);
    analogWrite(PIN_MOTOR_BACKWARD, 0);
  } else {
    microswitch_position = digitalRead(PIN_MICRO);
    if (microswitch_position == HIGH) {
      mc.log("WARNING: Camera already closed");
    }
  }
  mc.confirm(mc.CAMERA_CLOSE);
  mc.log("camera_close()");
  open = false;
}

boolean ReadDelay () {
  if (timer - frame_start >= timed_open) {
    return true;
  }
  return false;
}

void WatchDelay () {
  if (timer - delay_start >= timelapse_delay) {
    delaying = false;
    Camera();
  }
}

void ReadTimed () {
  if (!timed_exposure_open) {
    if (timer - frame_start > timed_open 
      && timer - frame_start < timed_open + timed_delay) {
       PauseTimedExposure();
    } else if (timer - frame_start > timed_open + timed_delay) {
      microswitch_position = digitalRead(PIN_MICRO);
      if (microswitch_position == HIGH) {
        Stop();
      }
      delay(2);//smooths out signal  
    }
  } 
  if (timed_exposure_open && timer - frame_start > timed_open + timed_delay) {
    StartTimedExposure();   
}

void PauseTimedExposure () {
  timed_exposure_open = true;
  analogWrite(PIN_MOTOR_FORWARD, 0);
  analogWrite(PIN_MOTOR_BACKWARD, 0);
}

void StartTimedExposure () {
  timed_exposure_open = false;
   if (direction) {
    analogWrite(PIN_MOTOR_FORWARD, fwd_speed);
    analogWrite(PIN_MOTOR_BACKWARD, 0);
  } else {
    analogWrite(PIN_MOTOR_BACKWARD, bwd_speed);
    analogWrite(PIN_MOTOR_FORWARD, 0);
  } 
}

void ReadMicro () {
  if (ReadDelay()) {
    microswitch_position = digitalRead(PIN_MICRO);
    if (microswitch_position == LOW 
        && microswitch_primed == false) {
      microswitch_primed = true;
    } else if (microswitch_position == HIGH 
              && microswitch_primed == true) {
      Stop();
    }
    delay(2);//smooths out signal
  }
}

void Stop () {
  delay(10);
  analogWrite(PIN_MOTOR_FORWARD, 0);
  analogWrite(PIN_MOTOR_BACKWARD, 0);
  
  running = false;
  microswitch_primed = false;

  if (direction) {
    counter += 1;  
  } else {
    counter -= 1;
  }

  timed_exposure_last = timer - frame_start;
  if (timed_exposure) {
    timed_avg = round((timed_avg + timed_exposure_last) / 2);
  } else {
    i_avg = round((i_avg + timed_exposure_last) / 2);
  }

  mc.confirm(mc.CAMERA);
  mc.log("Camera completed");
  mc.log(String(timed_exposure_last));
  if (timelapse) {
    delaying = true;
    delay_start = millis();
  }
}

void CameraDirection (boolean state) {
  direction = state;
  if (state) {
    timed_open = OpenTiming();
    mc.confirm(mc.CAMERA_FORWARD);
    mc.log("camera_direction(true)");
  } else {
    timed_open = OpenTiming();
    mc.confirm(mc.CAMERA_FORWARD);
    mc.log("camera_direction(false)");
  }
}

void State () {
  String stateString = String(mc.STATE);
  stateString += String(mc.CAMERA_EXPOSURE);
  if (timed_exposure) {
    stateString += String(timed_avg);
  } else {
    stateString += String(i_avg);
  }
  stateString += String(mc.STATE);
  mc.sendString(stateString);
}
